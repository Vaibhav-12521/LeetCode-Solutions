# 🧮 LeetCode Problem 4- Median of Two Sorted Arrays

**Difficulty:** Hard     

**Language Used:** C, Python

**Topic:** Linked List  

---

## 🧾 Problem Statement  

Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the median of the two sorted arrays.

The overall run time complexity should be `O(log (m+n))`.

 


---

## 💡 Example 1  
```
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3. Note that "bca" and "cab" are also correct answers.
```
---

## 💡 Example 2  
```
Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.
```

---

## 💡 Example 3  
```
Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
````

---

## ⚙️ Constraints   
- `nums1.length == m`
- `nums2.length == n`
- `0 <= m <= 1000`
- `0 <= n <= 1000`
- `1 <= m + n <= 2000`
- `-106 <= nums1[i], nums2[i] <= 106`
---


## 💻 C Solution

```c
double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) {
    if (nums1Size > nums2Size) {
        int* temp = nums1; nums1 = nums2; nums2 = temp;
        int tmp = nums1Size; nums1Size = nums2Size; nums2Size = tmp;
    }
    
    int m = nums1Size, n = nums2Size;
    int total = m + n;
    int half = total / 2;
    int left = 0, right = m;
    
    while (left <= right) {
        int i = (left + right) / 2;
        int j = half - i;
        
        double Aleft = (i > 0) ? nums1[i - 1] : -INFINITY;
        double Aright = (i < m) ? nums1[i] : INFINITY;
        double Bleft = (j > 0) ? nums2[j - 1] : -INFINITY;
        double Bright = (j < n) ? nums2[j] : INFINITY;
        
        if (Aleft <= Bright && Bleft <= Aright) {
            if (total % 2)
                return (Aright < Bright ? Aright : Bright);
            double leftMax = (Aleft > Bleft ? Aleft : Bleft);
            double rightMin = (Aright < Bright ? Aright : Bright);
            return (leftMax + rightMin) / 2.0;
        } else if (Aleft > Bright) {
            right = i - 1;
        } else {
            left = i + 1;
        }
    }
    return 0.0;
}

```

## 🐍 Python Solution

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        if len(nums1) > len(nums2):
            nums1, nums2 = nums2, nums1
        m, n = len(nums1), len(nums2)
        total = m + n
        half = total // 2                                                                
        left, right = 0, m
        while left <= right:
            i = (left + right) // 2
            j = half - i
            Aleft = nums1[i - 1] if i > 0 else float("-inf")
            Aright = nums1[i] if i < m else float("inf")
            Bleft = nums2[j - 1] if j > 0 else float("-inf")
            Bright = nums2[j] if j < n else float("inf")
            if Aleft <= Bright and Bleft <= Aright:
                if total % 2:
                    return float(min(Aright, Bright))
                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2
            elif Aleft > Bright:
                right = i - 1
            else:
                left = i + 1

```
---

## ⚙️ Step-by-Step Solution
1. **Ensure `nums1` is smaller** — so binary search happens on the shorter array.
2. **Binary search** for a partition index `i` in `nums1`.
3. Compute corresponding `j = (m + n) / 2 - i` for `nums2` — this splits both arrays into left and right halves.
4. Check if the partition is valid:

   ```
   nums1[i-1] <= nums2[j]  and  nums2[j-1] <= nums1[i]
   ```
5. If valid:

   * If total length is **odd**, median = `min(nums1[i], nums2[j])`
   * If **even**, median = average of `max(left parts)` and `min(right parts)`
6. If partition invalid:

   * Move search **left** if `nums1[i-1] > nums2[j]`
   * Move search **right** if `nums2[j-1] > nums1[i]`
7. Continue until valid partition found → return median.


---

## 🧮 Dry Run Example

**Input:**

```
nums1 = [1, 3]
nums2 = [2]
```

---

### Step 1: Setup

* m = 2, n = 1
* Swap → nums1 = [2], nums2 = [1, 3]
  (Now `nums1` is smaller, m = 1, n = 2)
* total = 3, half = 1

---

### Step 2: Binary search

`left = 0, right = 1`

#### 🔹 Iteration 1:

```
i = (0 + 1) / 2 = 0
j = half - i = 1 - 0 = 1
```

Compute boundaries:

```
Aleft  = -∞ (no element on left of nums1)
Aright = nums1[0] = 2
Bleft  = nums2[0] = 1
Bright = nums2[1] = 3
```

Check condition:

```
Aleft <= Bright  → -∞ <= 3 ✅
Bleft <= Aright  → 1 <= 2 ✅
```

✅ Valid partition found.

---

### Step 3: Find median

* Total = 3 → odd
* Median = min(Aright, Bright) = min(2, 3) = **2.0**

---

✅ **Final Answer:** `2.0`


---

### 📎 Connect with Me

<p align="center">
  <a href="https://github.com/Vaibhav-12521" target="_blank">
    <img src="https://img.shields.io/badge/GitHub-181717?style=for-the-badge&logo=github&logoColor=white" alt="GitHub Profile"/>
  </a>
  &nbsp;&nbsp;
  <a href="https://leetcode.com/u/vaibhav125s/" target="_blank">
    <img src="https://img.shields.io/badge/LeetCode-FFA116?style=for-the-badge&logo=leetcode&logoColor=black" alt="LeetCode Profile"/>
  </a>
  &nbsp;&nbsp;
  <a href="https://www.linkedin.com/in/vaibhavsingh125/" target="_blank">
    <img src="https://img.shields.io/badge/LinkedIn-0077B5?style=for-the-badge&logo=linkedin&logoColor=white" alt="LinkedIn Profile"/>
  </a>
</p>

<p align="center">
  <img src="https://visitor-badge.laobi.icu/badge?page_id=second-largest-problem" alt="visitor badge"/>
</p>
